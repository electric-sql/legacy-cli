defmodule ElectricCli.Bundle do
  @moduledoc """
  Manages the bundled, importable `index.js` file.
  """
  alias __MODULE__

  alias ElectricCli.Config.Environment
  alias ElectricCli.Config.Replication

  alias ElectricCli.Manifest
  alias ElectricCli.Manifest.Migration

  alias ElectricCli.Util

  @filename "index.js"
  @template_path "#{__DIR__}/templates/#{@filename}.eex"
  @template EEx.compile_file(@template_path)
  @external_resource @template_path

  @derive Jason.Encoder
  @type t() :: %Bundle{
          app: binary(),
          env: binary(),
          build: :local | :server,
          migrations: [%Migration{}],
          replication: %Replication{}
        }
  @enforce_keys [
    :app,
    :env,
    :build,
    :migrations
  ]
  defstruct [
    :app,
    :env,
    :build,
    :migrations,
    :replication
  ]

  use ExConstructor

  def new(map) do
    struct = super(map)

    build =
      case struct.build do
        x when x in [:local, :server] ->
          x

        "local" ->
          :local

        "server" ->
          :server
      end

    migrations =
      struct.migrations
      |> Enum.map(&Migration.new/1)

    replication =
      case struct.replication do
        nil ->
          nil

        alt ->
          alt
          |> Replication.new()
      end

    %{struct | build: build, migrations: migrations, replication: replication}
  end

  @doc """
  Initialise a new bundle.
  """
  @spec init(binary(), binary(), :local | :server, [%Migration{}], %Replication{}) :: %Bundle{}
  def init(app, env, build, migrations, replication) do
    %{app: app, env: env, build: build, migrations: migrations}
    |> Util.map_put_if(:replication, replication, not is_nil(replication))
    |> Bundle.new()
  end

  @doc """
  Load the bundle file into a `%Bundle{}` struct.
  """
  def load(dir) do
    dir = Path.expand(dir)
    relative_dir = Path.relative_to_cwd(dir)

    with {:exists, {true, path}} <- {:exists, exists?(dir)},
         {:ok, js_source} <- File.read(path),
         {:ok, json_str} <- parse_js_source(js_source),
         {:ok, data} <- Jason.decode(json_str) do
      {:ok, Bundle.new(data)}
    else
      {:exists, false} ->
        {:error, "`#{filepath(relative_dir)}` does not exist"}
    end
  end

  @doc """
  Saves the `%Bundle{}` into the `:dir/index.js` file where
  `dir` is `:output_dir/:app/:env`.
  """
  def save(
        %Bundle{
          app: app,
          env: env,
          build: build,
          migrations: migrations,
          replication: replication
        },
        dir
      ) do
    required = %{
      app: app,
      env: env,
      build: build,
      migrations: migrations
    }

    config =
      required
      |> Util.map_put_if(:replication, replication, not is_nil(replication))

    with {:ok, json_str} <- Jason.encode(config, pretty: true),
         {result, _} <- Code.eval_quoted(@template, config: json_str),
         :ok <- File.mkdir_p(dir) do
      dir
      |> filepath()
      |> File.write(result)
    end
  end

  @doc """
  Write a `%Bundle{}` from a `%Manifest{}` and an `%Environment{}`.
  """
  def write(
        %Manifest{app: app, migrations: migrations},
        %Environment{slug: env, replication: replication},
        build_type,
        output_dir
      )
      when build_type in [:local, :server] do
    dist_folder =
      [output_dir, app, env]
      |> Path.join()

    app
    |> init(env, build_type, migrations, replication)
    |> save(dist_folder)
  end

  defp exists?(dir) do
    path = filepath(dir)

    with true <- File.exists?(path) do
      {true, path}
    end
  end

  defp filepath(dir) when is_binary(dir) do
    dir
    |> Path.join(@filename)
  end

  defp parse_js_source(js_str) when is_binary(js_str) do
    has_banner =
      js_str
      |> String.contains?("Autogenerated ElectricSQL config file")

    parts =
      js_str
      |> String.trim()
      |> String.split("export default ")

    case {has_banner, Enum.count(parts), Enum.at(parts, -1)} do
      {true, 2, data} ->
        {:ok, data}

      _alt ->
        {:error, :invalid}
    end
  end
end
